CS224Lab No.:1Section No.: 1Name: Atakan AkarBilkent ID: 22203140Date: 09.10.2024


1)Formula Question.dataA:	.word 0B:	.word 0C:	.word 0questionA:	.asciiz "Enter A:\n"questionB: 	.asciiz "Enter B:\n"questionC:	.asciiz "Enter C:\n"explanation:	.asciiz "Result is equal to (a*b)modc/(a-b)\n"divisionByZeroError:	.asciiz "Division by zero error".text loop:    li $v0, 4                la $a0, questionA          syscall                     li $v0, 5               syscall    move $t0, $v0              li $v0, 4                la $a0, questionB          syscall                    li $v0, 5              syscall    move $t1, $v0                  li $v0, 4                la $a0, questionC         syscall                          li $v0, 5              syscall    move $t2, $v0          beq $t2,$zero,divisionByZero		sub $s4,$t0,$t1	beq $t4,$zero,divisionByZeroj doNotdivisionByZero:li $v0, 4                la $a0, divisionByZeroError       syscall    j loopdoNot:    mult $t0, $t1     mflo $s0 #so da a*b var        div $s0, $t2	    mfhi $s1 #s1 de modun cevab› var        sub $s2,$t0,$t1         div $s1,$s2    mflo $s3        li $v0, 4                la $a0, explanation         syscall                         li $v0, 1                move $a0,  $s3    syscall2)Menu Question.dataquestion1: 	.asciiz "Enter the size of the array:"question2:	.asciiz "Enter the number:"menu:	.asciiz "\n1)Find the maximum number stored in the array and display that number.\n2)Find the number of times the maximum number appears in the array.\n3)Find how many numbers we have (other than the maximum number) that we can divide the maximum number without a remainder.\n4)Quit.\n"choice:	.asciiz "Enter Choice:"size: 	.word 0	.align 4array:  .space 400			.text	la $a0,question1	li $v0,4	syscall 	li $v0, 5	syscall	sw $v0, size		lw $t0,size 	la $t1, array	addi $t2,$zero,0	beq $zero,$t0,doneloopForNumberInput:		la $a0,question2	li $v0,4	syscall 		li $v0, 5	syscall	sw $v0, 0($t1)	addi $t1,$t1,4	#sw $v0, size	addi $t2,$t2,1	bne $t2,$t0,loopForNumberInputmenuLoop:	addi $t0,$zero,1	addi $t1,$zero,2	addi $t2,$zero,3	addi $t3,$zero,4		la $a0,menu	li $v0,4	syscall 		li $v0, 5	syscall		move $t4,$v0	beq $t4,$t0,maxNumberCounterJr	j jump1maxNumberCounterJr:	jal maxNumberCounter	move $a0, $v1	li $v0, 1		syscalljump1:	beq $t4,$t1,appearJr	j jump2appearJr:	j appearjump2:	beq $t4,$t2,findDividentsjump3:		bne $t4,$t3,menuLoop			done:maxNumberCounter:	la $t0,array	lw $v1,0($t0)	lw $t2, size	addi $t3, $zero,0loopForTraversal:		lw $t5,0($t0)	slt $t4,$t5,$v1	beq $t4,$zero,changeTheMax	j doNotChangeMaxchangeTheMax:	move $v1,$t5doNotChangeMax:	addi $t0,$t0,4	addi $t3,$t3,1	bne $t2,$t3,loopForTraversal	jr $ra					appear:	jal maxNumberCounter	move $s0,$v1	la $t0,array	addi $s2,$zero,0	lw $t2, size	addi $t3, $zero,0loopForCounting:	lw $t4,0($t0)	addi $t0,$t0,4	addi $t3,$t3,1	beq $t4,$s0,increment	j doNotIncrementincrement:	addi $s2,$s2,1doNotIncrement:	bne $t2,$t3,loopForCounting	move $a0, $s2	li $v0, 1		syscall	j jump2				findDividents:	jal maxNumberCounter	move $s0,$v1	la $s7,array	addi $s2,$zero,0	lw $t2, size	addi $s5,$zero,0loopForDividentsTraversal:	lw $s6,0($s7)
	beq $s6,$zero,doNotPrint	move $a1,$s6	move $a0,$s0	jal mod	lw $t2, size	move $s1,$v0	beq $s6,$v1,doNotPrint	bne $s1,$zero,doNotPrint	addi $s5,$s5,1doNotPrint:	addi $s2,$s2,1	addi $s7,$s7,4	bne $s2,$t2,loopForDividentsTraversal	move $a0, $s5	li $v0, 1		syscall	j jump3				mod:	slt $t0,$a0,$zero #B 0dan küçük mü t0 a at	slt $t1,$a1,$zero #C 0dan küçük mü t1 e at	bne $t0, $zero,convertBforMod	j doNotConvertBforModconvertBforMod:	sub $a0,$zero,$a0doNotConvertBforMod:	bne $t1, $zero,convertD	j doNotConvertDconvertD:	sub $a1,$zero,$a1doNotConvertD:subtractToFindMod:	slt $t2, $a0, $a1 	bne $t2, $zero, endLoopForMod  	sub $a0, $a0, $a1    	j subtractToFindModendLoopForMod:	addi $t4,$zero,1	beq $t4,$t0,convertModToNegative	j doNotConvertForModconvertModToNegative:	sub $a0,$zero,$a0doNotConvertForMod:	move $v0,$a0	jr $ra3)Fibonacci Question####	Program3.asm is a loop implementation##	of the Fibonacci function##        ##################################					 	##		text segment		##						##################################	.text	 # execution starts here	li $a0,7	# to calculate fib(7)	#flb->fib olmal›	jal fib		# call fib	move $a0,$v0	# print result	li $v0, 1	syscall	la $a0,endl	# print newline	#must be endl not end syntax error	li $v0,4	syscall	li $v0,10	#must be 10 not 100 t finish the execution	syscall	# bye bye#------------------------------------------------fib:	move $v0,$a0	# initialise last element	addi $t2,$t2,2	blt $a0,$t2,done	# fib(0)=0, fib(1)=1	#must also be a register		li $t0,1	# second last element	li $v0,0	# last element	#the values must be reversedloop:	add $t1,$t0,$v0	# get next value	#dollar sign is missing	move $t0,$v0	# update second last	move $v0,$t1	# update last element	addi $a0,$a0,-1	# decrement count	#must be -1 and addi	bgt $a0,$zero,loop	# exit loop when count=0	# must be zero register $zer0 not zerodone:	jr $ra##################################					 	##     	 data segment		##						##################################	.dataendl:	.asciiz "\n"#### end of Program3.asm	